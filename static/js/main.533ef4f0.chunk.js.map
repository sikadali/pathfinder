{"version":3,"sources":["components/grid/node/Node.jsx","utils/StoreProvider.js","components/grid/Grid.jsx","components/navbar/icons/Reset.jsx","components/navbar/icons/Help.jsx","utils/dijkstra.js","utils/astar.js","components/animations/AnimateAlgorithm.js","components/navbar/pathfindings/Pathfindings.jsx","utils/kruskal.js","components/navbar/mazes/Mazes.jsx","components/navbar/NavBar.jsx","home/Home.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","row","col","isEnd","isStart","nodeStateClass","isWall","id","className","onContextMenu","onClick","StoreContext","React","createContext","StoreProvider","children","useState","Map","grid","setGrid","gridState","setGridState","useEffect","g","map","i","currentRow","j","set","getInitialGrid","hasStart","hasEnd","store","Provider","value","Grid","useContext","entries","rowkey","nodekey","node","prev","get","defineNode","e","preventDefault","clearNode","Reset","forEach","document","getElementById","Help","childToParent","mapToArray","gridMap","nodes","startNode","endNode","values","push","distance","isVisited","Number","POSITIVE_INFINITY","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","element","neighbor","previousNode","neighbors","length","filter","cost","heuristic","f","getNeighbors","sortOpenListByF","openList","insideList","list","heuristicManhattan","Math","abs","visualizeAlgorithm","algoIndex","visitedNodesInOrder","console","log","closestNode","shift","dijkstra","closedList","currentNode","costNode","costNodeIsBest","astar","nodesInShortestPathOrder","undefined","animateAlgorithm","alert","setTimeout","animateShortestPath","Pathfindings","algorithm","setAlgorithm","selectAlgorithm","type","visualizeGo","mergeKruskalGroup","edge","maze","temp","first","kruskalID","center","secondGroup","second","setEdges","rows","cols","edges","mazeMap","cells","key","Mazes","visualizeKruskal","openEdgesInOrder","max","index","floor","random","splice","kruskal","NavBar","src","alt","delayHide","place","effect","globalEventOff","home","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.533ef4f0.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nexport const Node = (props) => {\n\tconst { row, col, isEnd, isStart, isWall} = props;\n\tconst nodeStateClass = isWall ? 'wall' : isStart ? 'start' : isEnd ? 'end' : '';\n\n\treturn (\n\t\t<div\n\t\t\tid={`node-${row}-${col}`}\n\t\t\tclassName={`node ${nodeStateClass}`}\n\t\t\tonContextMenu={props.onContextMenu}\n\t\t\tonClick={props.onClick}\n\t\t/>\n\t);\n};\n","import React, { useState, useEffect } from 'react';\n\nconst TOTAL_ROW = 29;\nconst TOTAL_COL = 61;\n\nexport const StoreContext = React.createContext(null);\n\nconst StoreProvider = ({ children }) => {\n\n    //Data for grid management\n\tconst [grid, setGrid] = useState(new Map());\n    //Data for node state management\n    const [gridState, setGridState] = useState({});\n    \n    const getInitialGrid = () => {\n\t\tconst map = new Map();\n\t\tfor (let i = 0; i < TOTAL_ROW; i++) {\n\t\t\tconst currentRow = new Map();\n\t\t\tfor (let j = 0; j < TOTAL_COL; j++) {\n\t\t\t\tcurrentRow.set(j, { row: i, col: j, isStart: false, isWall: false, isEnd: false});\n\t\t\t}\n\t\t\tmap.set(i, new Map(currentRow));\n\t\t}\n\t\treturn (map);\n\t}\n\tuseEffect(() => {\n\t\tconst g = getInitialGrid();\n\t\tsetGrid(g);\n        setGridState({hasStart: false, hasEnd: false});\n\t}, [])\n\n    \n\n\tconst store = {\n\t\tgrid: [ grid, setGrid ],\n        gridState: [ gridState, setGridState ]\n\t};\n\n\treturn( \n        <StoreContext.Provider value={store}>\n            {children}\n        </StoreContext.Provider>\n    );\n};\nexport default StoreProvider;","import React, { useContext } from 'react'\nimport './Grid.scss'\nimport { Node } from './node/Node'\nimport { StoreContext } from '../../utils/StoreProvider';\n\n\nconst Grid = () => {\n\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n    const defineNode = (rowkey, nodekey, node) => {\n        if(gridState.hasStart) {\n            if(gridState.hasEnd) {\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true, isEnd: false, isStart: false})) );\n            }\n            else{\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: true, isStart: false})) );\n                setGridState({...gridState, hasEnd: true});\n            }\n        }\n        else {\n            setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: true})) );\n            setGridState({...gridState, hasStart: true});\n        }        \n\t};\n\n    const clearNode = (rowkey, nodekey, node) => {\n        if(node.isStart){\n            setGridState({...gridState, hasStart: false});\n        }\n        if(node.isEnd){\n            setGridState({...gridState, hasEnd: false});\n        }\n\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: false})) );\n\t};\n\n    return (\n        <div className=\"grid\">\n\t\t\t{[...grid.entries()].map(([rowkey, row]) => {\n\t\t\t\treturn(\n\t\t\t\t\t<div key={rowkey} className=\"grid_rows\">\n\t\t\t\t\t\t{[...row.entries()].map( ([nodekey, node]) => {\n\t\t\t\t\t\t\tconst {row, col, isWall, isEnd, isStart} = node;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Node \n\t\t\t\t\t\t\t\t\tkey={nodekey} \n\t\t\t\t\t\t\t\t\trow={row} \n                                    col={col}\n                                    isWall={isWall} \n\t\t\t\t\t\t\t\t\tisEnd={isEnd}\n\t\t\t\t\t\t\t\t\tisStart={isStart}\n                                    onClick={()=>defineNode(rowkey, nodekey, node)}\n                                    onContextMenu={(e) => {\n                                        e.preventDefault();\n                                        clearNode(rowkey, nodekey, node);\n                                    }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t</div>\n    )\n}\n\nexport default Grid;","import React, { useContext } from 'react'\nimport RotateLeftIcon from '@material-ui/icons/RotateLeft';\nimport { StoreContext } from '../../../utils/StoreProvider';\n\nexport default function Reset() {\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n\n    const resetGrid = () => {\n        // if there is a start node || end node (possibly some visited nodes) \n        // => then only all non-wall nodes are reset\n        if(gridState.hasStart || gridState.hasEnd) {\n            grid.forEach((row, rowkey) => {\n                row.forEach((node, nodekey) => {\n                    if (!node.isWall) {\n                        // reset the node properties\n                        setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n                            .set(nodekey, {...node, isEnd: false, isStart: false})) );\n                        // reset the node style, in case it was visited by an algorithm\n                        document.getElementById(`node-${node.row}-${node.col}`)\n                            .className = \"node\";\n                    }\n                })\n            })\n            setGridState({...gridState, hasEnd: false, hasStart: false});\n        }\n        // else, remove the potential wall nodes present\n        else{\n            grid.forEach((row, rowkey) => {\n                row.forEach((node, nodekey) => {\n                    // reset the node properties\n                    setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n                        .set(nodekey, {...node, isWall: false, isEnd: false, isStart: false})) );\n                    // reset the node style, in case it was visited by an algorithm\n                    document.getElementById(`node-${node.row}-${node.col}`)\n                        .className = \"node\";\n                })\n            })\n            setGridState({...gridState, hasEnd: false, hasStart: false});\n        }\n    }\n\n    return (\n        <div>\n            <RotateLeftIcon className=\"icon\" data-tip=\"Reset\" onClick={() => resetGrid()}/>\n        </div>\n    )\n}\n","import React from 'react'\nimport HelpOutlineIcon from '@material-ui/icons/HelpOutline';\n\nexport default function Help({childToParent}) {\n    return (\n        <div>\n            <HelpOutlineIcon className=\"icon\" data-tip=\"Help\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(gridMap) {\n    const {grid, nodes, endNode} = mapToArray(gridMap);\n\tconst visitedNodesInOrder = [];\n\n\twhile (!!nodes.length) { // '!!' to convert length of unvisited nodes to boolean true since it reaches 0 and begin false\n\t\tsortNodesByDistance(nodes);\n\t\tconst closestNode = nodes.shift();\n\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue\n\t\t}\n\t\t// If the closest node is at a distance of infinity, we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === 1000) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\n\t\tif (closestNode.row === endNode.row && closestNode.col === endNode.col) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\t\tupdateUnvisitedNeighbors(closestNode, grid, nodes);\n\t}\n\t\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node};\n\t\t\t\tcurrentRow.push({...node, distance: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => {return(nodeA.distance - nodeB.distance)});\n}\n\nconst updateUnvisitedNeighbors = (node, grid, nodes) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const element of nodes) {\n\t\tfor(const neighbor of unvisitedNeighbors){\n\t\t\tif(neighbor.row === element.row && neighbor.col === element.col){\n\t\t\t\telement.distance = node.distance + 1;\n\t\t\t\telement.previousNode = node;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors.filter(neighbor => !neighbor.isVisited)\n\t);\n}","export const astar = (gridMap) => {\n    const {grid, startNode, endNode} = mapToArray(gridMap);\n\tconst closedList = [];   //visitedNodesInOrder\n\n    const openList = [];\n    openList.push(startNode)\n\n    while (!!openList.length){\n        // take nodeU, the node from openList with the biggest heuristic (manhattan distance in this case)\n        sortOpenListByF(openList)\n        const currentNode = openList.shift()\n\n        // loop : for each neighbor of nodeU inside the grid\n        const neighbors = getNeighbors(currentNode, grid);\n        for(let neighbor of neighbors){\n            // if neighbor already been visited, or is a wall node, skip to the next neighbor\n            if ( insideList(neighbor, closedList) || neighbor.isWall ) {\n                continue\n            }\n\n            // the node cost is the shortest distance from start to current node, we need to check if\n            // the path we have arrived at this neighbor is the shortest one we have seen yet\n            var costNode = currentNode.cost + 1; // 1 is the distance from a node to its neighbor\n            var costNodeIsBest = false;\n    \n    \n            if( !insideList(neighbor, openList) ) {\n                // This the the first time we have arrived at this node, it must be the best\n                // Also, we need to take the h (heuristic) score since we haven't done so yet\n                costNodeIsBest = true;\n                neighbor.heuristic = heuristicManhattan(neighbor, endNode);\n                openList.push(neighbor);\n            }\n            else if(costNode < neighbor.cost) {\n                // We have already seen the node, but last time it had a worse cost (distance from start)\n                costNodeIsBest = true;\n            }\n    \n            if(costNodeIsBest) {\n                // Found an optimal (so far) path to this node.  Store info on how we got here and\n                // just how good it really is...\n                neighbor.previousNode = currentNode;\n                neighbor.cost = costNode;\n                neighbor.f = neighbor.cost + neighbor.heuristic;\n            }\n        }\n        currentNode.isVisited = true; //after, try to comment this line\n        closedList.push(currentNode)\n\n        // if the node taken is the endNode then END\n        if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n\t\t\treturn (closedList)\n\t\t}\n    }\n    // end program (with error)\n    console.log(\"ERROR: A* not giving results\")\n    // inspired from https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node, cost: 0, heuristic: 0, f: 0, isVisited: false};\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst getNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors //.filter(neighbor => !neighbor.isVisited)\n\t);\n}\n\nconst sortOpenListByF = (openList) => {\n    openList.sort((nodeA, nodeB) => {return(nodeA.f - nodeB.f)});\n}\n\nconst insideList = (neighbor, list) => {\n    for (let node of list) {\n        if (node.row === neighbor.row && node.col === neighbor.col) {\n            return true\n        }\n    }\n    return false\n}\n\nconst heuristicManhattan = (nodeA, nodeB) => {\n    // This is the Manhattan distance\n    var d1 = Math.abs (nodeB.row - nodeA.row);\n    var d2 = Math.abs (nodeB.col - nodeA.col);\n    return d1 + d2;\n}","import { dijkstra } from \"../../utils/dijkstra\";\nimport { astar } from \"../../utils/astar\";\n\nexport const visualizeAlgorithm = (gridState, grid, algoIndex) => {\n  if (gridState.hasStart) {\n    if (gridState.hasEnd) {\n        let visitedNodesInOrder\n        switch (algoIndex) {\n            case 0:\n                console.log('Running Dijkstra Algorithm');\n                visitedNodesInOrder = dijkstra(grid);\n                break;\n            case 1:\n                console.log('Running A* Algorithm');\n                visitedNodesInOrder = astar(grid);\n                break;\n            default:\n              console.log(`There is no algorithm with this index`);\n          }\n        \n        console.log('visitedNodesInOrder => ', visitedNodesInOrder)\n\n        const nodesInShortestPathOrder = [];\n        let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\n\n        while (currentNode !== undefined) {\n            nodesInShortestPathOrder.push(currentNode);\n            currentNode = currentNode.previousNode;\n        }\n        animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    } else {\n        alert(\"Please define a finish node\");\n    }\n  } else {\n    alert(\"Please define a start node\");\n  }\n};\n\nconst animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n  for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n    if (i === visitedNodesInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(nodesInShortestPathOrder);\n      }, 10 * i);\n      return;\n    }\n    setTimeout(() => {\n      document.getElementById(\n        `node-${visitedNodesInOrder[i].row}-${visitedNodesInOrder[i].col}`\n      ).className = \"node node-visited\";\n    }, 10 * i);\n  }\n};\n\nconst animateShortestPath = (nodesInShortestPathOrder) => {\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    setTimeout(() => {\n      document.getElementById(\n        `node-${nodesInShortestPathOrder[i].row}-${nodesInShortestPathOrder[i].col}`\n      ).className = \"node node-shortest-path\";\n    }, 50 * i);\n  }\n};\n","import React, { useContext, useState } from 'react';\nimport './Pathfindings.scss'\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { visualizeAlgorithm } from '../../animations/AnimateAlgorithm';\n\nexport default function Pathfindings() {\n\n    const {\n        grid: [grid, ], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('PATH !');\n\n    const visualizeGo = (algorithm) => {\n      if (algorithm === 'PATH !'){\n        alert('Select a pathfinding algorithm');\n      }\n      if (algorithm === 'DIJKSTRA PATH !'){\n        visualizeAlgorithm(gridState, grid, 0);\n        setAlgorithm('PATH !');\n      }\n      if (algorithm === 'A* PATH !'){\n        visualizeAlgorithm(gridState, grid, 1);\n        setAlgorithm('PATH !');\n      }\n    }\n\n    const selectAlgorithm = (algorithm) => {\n      switch(algorithm) {\n        case \"dijkstra\": { setAlgorithm('DIJKSTRA PATH !'); break; }\n        case \"astar\": { setAlgorithm('A* PATH !'); break; }\n        case \"greedy\": { setAlgorithm('GREEDY PATH !'); break; }\n        case \"bfs\": { setAlgorithm('BFS PATH !'); break; }\n        case \"dfs\": { setAlgorithm('DFS PATH !'); break; }\n        default: { break;}\n      }\n    }\n\n    return (\n      <div className='container'>\n        <div className=\"pathfindings\">\n          <span>Pathfinding algorithm</span>\n          <div className=\"options\">\n            <span onClick={()=>selectAlgorithm('dijkstra')}>Dijkstra's algorithm</span>\n            <span onClick={()=>selectAlgorithm('astar')}>A* algorithm</span>\n            <span onClick={()=>selectAlgorithm('greedy')}>Greedy algorithm</span>\n            <span onClick={()=>selectAlgorithm('bfs')}>Breadth-First Search algoriithm</span>\n            <span onClick={()=>selectAlgorithm('dfs')}>Depth-First Search algorithm</span>\n          </div>\n        </div>\n        <input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n      </div>\n    );\n}\n","//RANDOMIZED KRUSKAL ALGORITHM : essayer la version avec la moitie des cellules deja ouvertes !!!!!\nexport function kruskal(mazeMap) {\n    \n    const {maze, cells, startNode, endNode, hasStart, hasEnd} = mapToArray(mazeMap);\n\tconst openEdgesInOrder = [];\n\n    //Step 1 : make the edges set; \n        //an edge is a linear(to say not diagonal) combinaison of three nodes, and is only 'perpendicularly' adjacent to others edges\n    let edges = setEdges(maze);\n\n    //Step 2 : While the set of edges is not empty\n    while (!!edges.length) {\n        //Randomly get an edge and remove it from the set\n        const index = getRandomInt(edges.length)\n        const edge = edges[index];\n        edges.splice(index, 1);\n        \n\n        //If cells are not already in the same bucket: Connect them !!!PROBLEM HERE!!!\n        if (maze[edge.first.row][edge.first.col].kruskalID !== maze[edge.second.row][edge.second.col].kruskalID){\n            //merge edges in the maze\n            mergeKruskalGroup(edge, maze);\n            openEdgesInOrder.push(edge);\n        }\n    }\n    console.log(openEdgesInOrder)\n    console.log(maze)\n    return (openEdgesInOrder);\n}\n\nconst mergeKruskalGroup = (edge, maze) => {\n    const temp = maze[edge.first.row][edge.first.col].kruskalID;\n    maze[edge.center.row][edge.center.col].kruskalID = temp;\n\n    const secondGroup = maze[edge.second.row][edge.second.col].kruskalID;\n\n    for(let row of maze){\n        for(let node of row){\n            if (node.kruskalID === secondGroup){\n                node.kruskalID = temp;\n            }\n        }\n    }\n}\n\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction shuffle(array) {\n    let currentIndex = array.length, temporaryValue, randomIndex;\n  \n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n  \n    return array;\n}\n\n\nconst setEdges = (maze) => {\n    const rows = maze.length;\n    const cols = maze[0].length;\n\n    const edges = [];\n    for(let i=0; i<rows; i++){\n        for(let j=0; j<cols; j++){\n            const edge = {first: {}, center: {}, second: {}};\n            if(i%2 !== 0 && j%2 === 0){\n                edge.first = {...maze[i-1][j]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i+1][j]};\n\n                edges.push(edge);\n            }\n            if(i%2 === 0 && j%2 !== 0){\n                edge.first = {...maze[i][j-1]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i][j+1]};\n\n                edges.push(edge);\n            }\n        }\n    }\n    return edges;\n}\n\nconst mapToArray = (mazeMap) => {\n    const maze = [];\n\tconst cells = [];\n    let startNode = {};\n    let endNode = {};\n    let hasStart = false;\n    let hasEnd = false;\n\n    let key = 0;\n    for(let row of mazeMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n\n            currentRow.push({...node, kruskalID: key});\n\t\t\tcells.push({...node, kruskalID: key}); \n            key = key + 1;\n\n            if(node.isStart){\n\t\t\t\thasStart = true;\n                startNode = {...node};\n            }\n            if(node.isEnd){\n                hasEnd = true;\n                endNode = {...node};\n            }\n        }\n        maze.push(currentRow);\n\t}\n    return {maze: maze, cells: cells, startNode: startNode, endNode: endNode, hasStart: hasStart, hasEnd: hasEnd};\n}\n","import React, { useContext, useState } from 'react';\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { kruskal } from '../../../utils/kruskal';\n\nexport default function Mazes() {\n\n\tconst {\n        grid: [grid, setGrid], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('MAZE !');\n\n\tconst visualizeGo = (algorithm) => {\n\t\tif (algorithm === 'MAZE !'){\n\t\t  alert('Select a maze algorithm');\n\t\t}\n\t\tif (algorithm === 'KRUSKAL MAZE !'){\n\t\t  visualizeKruskal();\n\t\t  setAlgorithm('MAZE !');\n\t\t}\n\t  }\n\n    const selectAlgorithm = (algorithm) => {\n        switch(algorithm) {\n          case \"kruskal\": { setAlgorithm('KRUSKAL MAZE !'); break; }\n          case \"prim\": { setAlgorithm('PRIM MAZE !'); break; }\n          case \"wilson\": { setAlgorithm('WILSON MAZE !'); break; }\n          case \"aldous\": { setAlgorithm('ALDOUS-BRODER MAZE !'); break; }\n          default: { break;}\n        }\n    }\n\n\tconst visualizeKruskal = () => {\n\t\tconst openEdgesInOrder = kruskal(grid);\n\n\t\t//Put all nodes to wall mode\n\t\tfor(let [rowkey, row] of grid.entries()){\n\t\t\tfor(let [nodekey, node] of row.entries()){\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true,})) );\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < openEdgesInOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].center.row, new Map(prev.get(openEdgesInOrder[i].center.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].center.col, {...openEdgesInOrder[i].center, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].first.row, new Map(prev.get(openEdgesInOrder[i].first.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].first.col, {...openEdgesInOrder[i].first, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].second.row, new Map(prev.get(openEdgesInOrder[i].second.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].second.col, {...openEdgesInOrder[i].second, isWall: false,})) );\n\t\t\t}, 5)\n\t\t}\n\t}\n\t\n\n\treturn (\n\t\t<div className=\"container\">\n\t\t\t<div className=\"mazes\">\n\t\t\t\t<span>Maze algorithm</span>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('kruskal')}>Kruskal's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('prim')}>Prim's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('wilson')}>Wilson's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('aldous')}>Aldous-Broder algorithm</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n\t\t</div>\n\t);\n}\n","import React from 'react'\nimport './NavBar.scss'\nimport ReactTooltip from 'react-tooltip';\nimport Reset from './icons/Reset';\nimport Help from './icons/Help';\nimport Pathfindings from './pathfindings/Pathfindings';\nimport Mazes from './mazes/Mazes';\n\nexport default function NavBar() {\n\n    return (\n        <div className='navbar'>\n            <div className=\"container\">\n\t\t\t\t<div className=\"left\">\n\t\t\t\t\t<div className=\"logo\">\n\t\t\t\t\t\t<img src=\"https://cdn-icons-png.flaticon.com/512/182/182580.png\" alt=\"from flaticon\" />\n\t\t\t\t\t\t<span>Pathfinder</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Mazes/>\n          \t\t\t<Pathfindings/>\n\t\t\t\t</div>\n        <div className=\"right\">\n\t\t\t\t\t<Reset/>\n\t\t\t\t\t<Help/>\n\t\t\t\t\t<ReactTooltip className='tooltip-class' delayHide={500} place='bottom' effect='solid' globalEventOff=\"click\" />\n\t\t\t\t</div>\n\t\t\t</div>\n        </div>\n    )\n}\n","import React from 'react'\nimport Grid from '../components/grid/Grid'\nimport NavBar from '../components/navbar/NavBar'\nimport StoreProvider from '../utils/StoreProvider'\nimport './Home.scss'\n\nexport default function home() {\n    return (\n        <StoreProvider>\n            <div className='home'>\n                <NavBar/>\n                <Grid/>\n            </div>\n        </StoreProvider>\n    )\n}\n","import './App.scss';\nimport Home from './home/Home';\n\nfunction App() {\n  return (\n    <div>\n      <Home/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}