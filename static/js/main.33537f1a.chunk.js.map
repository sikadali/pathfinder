{"version":3,"sources":["components/grid/node/Node.jsx","utils/StoreProvider.js","components/grid/Grid.jsx","components/navbar/icons/Reset.jsx","components/navbar/icons/Help.jsx","utils/dijkstra.js","utils/astar.js","components/animations/AnimateAlgorithm.js","components/navbar/pathfindings/Pathfindings.jsx","utils/kruskal.js","components/navbar/mazes/Mazes.jsx","components/navbar/NavBar.jsx","home/Home.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","row","col","isEnd","isStart","nodeStateClass","isWall","id","className","onContextMenu","onClick","StoreContext","React","createContext","StoreProvider","children","useState","Map","grid","setGrid","gridState","setGridState","useEffect","g","map","i","currentRow","j","set","getInitialGrid","hasStart","hasEnd","hasWall","store","Provider","value","Grid","useContext","entries","rowkey","nodekey","node","prev","get","defineNode","e","preventDefault","clearNode","Reset","visitingReset","hasVisited","forEach","document","getElementById","defaultReset","Help","childToParent","mapToArray","gridMap","nodes","startNode","endNode","values","push","distance","isVisited","Number","POSITIVE_INFINITY","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","element","neighbor","previousNode","neighbors","length","filter","cost","heuristic","f","getNeighbors","sortOpenListByF","openList","insideList","list","heuristicManhattan","Math","abs","visualizeAlgorithm","algoIndex","visitedNodesInOrder","console","log","closestNode","shift","dijkstra","closedList","currentNode","costNode","costNodeIsBest","astar","nodesInShortestPathOrder","undefined","animateAlgorithm","alert","setTimeout","animateShortestPath","Pathfindings","algorithm","setAlgorithm","selectAlgorithm","type","visualizeGo","mergeKruskalGroup","edge","maze","temp","first","kruskalID","center","secondGroup","second","setEdges","rows","cols","edges","mazeMap","cells","key","Mazes","visualizeKruskal","openEdgesInOrder","max","index","floor","random","splice","kruskal","openEdge","NavBar","src","alt","delayHide","place","effect","globalEventOff","home","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.33537f1a.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nexport const Node = (props) => {\n\tconst { row, col, isEnd, isStart, isWall} = props;\n\tconst nodeStateClass = isWall ? 'wall' : isStart ? 'start' : isEnd ? 'end' : '';\n\n\treturn (\n\t\t<div\n\t\t\tid={`node-${row}-${col}`}\n\t\t\tclassName={`node ${nodeStateClass}`}\n\t\t\tonContextMenu={props.onContextMenu}\n\t\t\tonClick={props.onClick}\n\t\t/>\n\t);\n};\n","import React, { useState, useEffect } from 'react';\n\nconst TOTAL_ROW = 29;\nconst TOTAL_COL = 61;\n\nexport const StoreContext = React.createContext(null);\n\nconst StoreProvider = ({ children }) => {\n\n    //Data for grid management\n\tconst [grid, setGrid] = useState(new Map());\n    //Data for node state management\n    const [gridState, setGridState] = useState({});\n    \n    const getInitialGrid = () => {\n\t\tconst map = new Map();\n\t\tfor (let i = 0; i < TOTAL_ROW; i++) {\n\t\t\tconst currentRow = new Map();\n\t\t\tfor (let j = 0; j < TOTAL_COL; j++) {\n\t\t\t\tcurrentRow.set(j, { row: i, col: j, isStart: false, isWall: false, isEnd: false});\n\t\t\t}\n\t\t\tmap.set(i, new Map(currentRow));\n\t\t}\n\t\treturn (map);\n\t}\n\tuseEffect(() => {\n\t\tconst g = getInitialGrid();\n\t\tsetGrid(g);\n        setGridState({hasStart: false, hasEnd: false, hasWall: false});\n\t}, [])\n\n    \n\n\tconst store = {\n\t\tgrid: [ grid, setGrid ],\n        gridState: [ gridState, setGridState ]\n\t};\n\n\treturn( \n        <StoreContext.Provider value={store}>\n            {children}\n        </StoreContext.Provider>\n    );\n};\nexport default StoreProvider;","import React, { useContext } from 'react'\nimport './Grid.scss'\nimport { Node } from './node/Node'\nimport { StoreContext } from '../../utils/StoreProvider';\n\n\nconst Grid = () => {\n\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n    const defineNode = (rowkey, nodekey, node) => {\n        if(gridState.hasStart) {\n            if(gridState.hasEnd) {\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true, isEnd: false, isStart: false})) );\n                setGridState({...gridState, hasWall: true});\n            }\n            else{\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: true, isStart: false})) );\n                setGridState({...gridState, hasEnd: true});\n            }\n        }\n        else {\n            setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: true})) );\n            setGridState({...gridState, hasStart: true});\n        }     \n\t};\n\n    const clearNode = (rowkey, nodekey, node) => {\n        if(node.isStart){\n            setGridState({...gridState, hasStart: false});\n        }\n        if(node.isEnd){\n            setGridState({...gridState, hasEnd: false});\n        }\n        if(node.isWall){\n            setGridState({...gridState, hasWall: false});\n        }\n\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: false})) );\n\t};\n\n    return (\n        <div className=\"grid\">\n\t\t\t{[...grid.entries()].map(([rowkey, row]) => {\n\t\t\t\treturn(\n\t\t\t\t\t<div key={rowkey} className=\"grid_rows\">\n\t\t\t\t\t\t{[...row.entries()].map( ([nodekey, node]) => {\n\t\t\t\t\t\t\tconst {row, col, isWall, isEnd, isStart} = node;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Node \n\t\t\t\t\t\t\t\t\tkey={nodekey} \n\t\t\t\t\t\t\t\t\trow={row} \n                                    col={col}\n                                    isWall={isWall} \n\t\t\t\t\t\t\t\t\tisEnd={isEnd}\n\t\t\t\t\t\t\t\t\tisStart={isStart}\n                                    onClick={()=>defineNode(rowkey, nodekey, node)}\n                                    onContextMenu={(e) => {\n                                        e.preventDefault();\n                                        clearNode(rowkey, nodekey, node);\n                                    }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t</div>\n    )\n}\n\nexport default Grid;","import React, { useContext } from 'react'\nimport RotateLeftIcon from '@material-ui/icons/RotateLeft';\nimport { StoreContext } from '../../../utils/StoreProvider';\n\nexport default function Reset() {\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n    const resetGrid = () => {\n        visitingReset()\n    }\n    \n    const visitingReset = () => {\n        let hasVisited = false\n        grid.forEach((row) => {\n            row.forEach((node) => {\n                // first check if node has been visited\n                if (document.getElementById(`node-${node.row}-${node.col}`).className ===  \"node node-visited\" ||\n                    document.getElementById(`node-${node.row}-${node.col}`).className ===  \"node node-shortest-path\"){\n                       hasVisited = true\n                }\n                if (!node.isWall && !node.isStart && !node.isEnd) {\n                    document.getElementById(`node-${node.row}-${node.col}`)\n                        .className = \"node\";\n                }\n                if (node.isStart) {\n                    document.getElementById(`node-${node.row}-${node.col}`)\n                        .className = \"node start\";\n                }\n                if (node.isEnd) {\n                    document.getElementById(`node-${node.row}-${node.col}`)\n                        .className = \"node end\";\n                }\n            })\n        })\n        if (!hasVisited){ // there had no visited nodes then continue\n            defaultReset()\n        }\n    }\n    const defaultReset = () => {\n        if (gridState.hasWall) { // if there is walls, remove them only\n            grid.forEach((row, rowkey) => {\n                row.forEach((node, nodekey) => {\n                    // reset the wall node properties\n                    if (node.isWall) {\n                        setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n                        .set(nodekey, {...node, isWall: false})) );\n                    }\n                })\n            })\n            setGridState({...gridState, hasWall: false});\n        } else { // else, there is only start & end node left, remove them\n            grid.forEach((row, rowkey) => {\n                row.forEach((node, nodekey) => {\n                    // reset the start & end nodes' properties\n                    setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n                        .set(nodekey, {...node, isEnd: false, isStart: false})) );\n                })\n            })\n            setGridState({...gridState, hasEnd: false, hasStart: false});\n        }\n    }\n\n    return (\n        <div>\n            <RotateLeftIcon className=\"icon\" data-tip=\"Reset\" onClick={() => resetGrid()}/>\n        </div>\n    )\n}\n","import React from 'react'\nimport HelpOutlineIcon from '@material-ui/icons/HelpOutline';\n\nexport default function Help({childToParent}) {\n    return (\n        <div>\n            <HelpOutlineIcon className=\"icon\" data-tip=\"Help\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(gridMap) {\n    const {grid, nodes, endNode} = mapToArray(gridMap);\n\tconst visitedNodesInOrder = [];\n\n\twhile (!!nodes.length) { // '!!' to convert length of unvisited nodes to boolean true since it reaches 0 and begin false\n\t\tsortNodesByDistance(nodes);\n\t\tconst closestNode = nodes.shift();\n\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue\n\t\t}\n\t\t// If the closest node is at a distance of infinity, we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === 1000) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\n\t\tif (closestNode.row === endNode.row && closestNode.col === endNode.col) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\t\tupdateUnvisitedNeighbors(closestNode, grid, nodes);\n\t}\n\t\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node};\n\t\t\t\tcurrentRow.push({...node, distance: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => {return(nodeA.distance - nodeB.distance)});\n}\n\nconst updateUnvisitedNeighbors = (node, grid, nodes) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const element of nodes) {\n\t\tfor(const neighbor of unvisitedNeighbors){\n\t\t\tif(neighbor.row === element.row && neighbor.col === element.col){\n\t\t\t\telement.distance = node.distance + 1;\n\t\t\t\telement.previousNode = node;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors.filter(neighbor => !neighbor.isVisited)\n\t);\n}","export const astar = (gridMap) => {\n    const {grid, startNode, endNode} = mapToArray(gridMap);\n\tconst closedList = [];   //visitedNodesInOrder\n\n    const openList = [];\n    openList.push(startNode)\n\n    while (!!openList.length){\n        // take nodeU, the node from openList with the biggest heuristic (manhattan distance in this case)\n        sortOpenListByF(openList)\n        const currentNode = openList.shift()\n\n        // loop : for each neighbor of nodeU inside the grid\n        const neighbors = getNeighbors(currentNode, grid);\n        for(let neighbor of neighbors){\n            // if neighbor already been visited, or is a wall node, skip to the next neighbor\n            if ( insideList(neighbor, closedList) || neighbor.isWall ) {\n                continue\n            }\n\n            // the node cost is the shortest distance from start to current node, we need to check if\n            // the path we have arrived at this neighbor is the shortest one we have seen yet\n            var costNode = currentNode.cost + 1; // 1 is the distance from a node to its neighbor\n            var costNodeIsBest = false;\n    \n    \n            if( !insideList(neighbor, openList) ) {\n                // This the the first time we have arrived at this node, it must be the best\n                // Also, we need to take the h (heuristic) score since we haven't done so yet\n                costNodeIsBest = true;\n                neighbor.heuristic = heuristicManhattan(neighbor, endNode);\n                openList.push(neighbor);\n            }\n            else if(costNode < neighbor.cost) {\n                // We have already seen the node, but last time it had a worse cost (distance from start)\n                costNodeIsBest = true;\n            }\n    \n            if(costNodeIsBest) {\n                // Found an optimal (so far) path to this node.  Store info on how we got here and\n                // just how good it really is...\n                neighbor.previousNode = currentNode;\n                neighbor.cost = costNode;\n                neighbor.f = neighbor.cost + neighbor.heuristic;\n            }\n        }\n        closedList.push(currentNode)\n\n        // if the node taken is the endNode then END\n        if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n\t\t\treturn (closedList)\n\t\t}\n    }\n    // end program (with error)\n    console.log(\"ERROR: A* not giving results\")\n    // inspired from https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node, cost: 0, heuristic: 0, f: 0};\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst getNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors\n\t);\n}\n\nconst sortOpenListByF = (openList) => {\n    openList.sort((nodeA, nodeB) => {return(nodeA.f - nodeB.f)});\n}\n\nconst insideList = (neighbor, list) => {\n    for (let node of list) {\n        if (node.row === neighbor.row && node.col === neighbor.col) {\n            return true\n        }\n    }\n    return false\n}\n\nconst heuristicManhattan = (nodeA, nodeB) => {\n    // This is the Manhattan distance\n    var d1 = Math.abs (nodeB.row - nodeA.row);\n    var d2 = Math.abs (nodeB.col - nodeA.col);\n    return d1 + d2;\n}","import { dijkstra } from \"../../utils/dijkstra\";\nimport { astar } from \"../../utils/astar\";\n\nexport const visualizeAlgorithm = (gridState, grid, algoIndex) => {\n  if (gridState.hasStart) {\n    if (gridState.hasEnd) {\n        let visitedNodesInOrder\n        switch (algoIndex) {\n            case 0:\n                console.log('Running Dijkstra Algorithm');\n                visitedNodesInOrder = dijkstra(grid);\n                break;\n            case 1:\n                console.log('Running A* Algorithm');\n                visitedNodesInOrder = astar(grid);\n                break;\n            case 2:\n                console.log('Running DFS Algorithm');\n                // visitedNodesInOrder = dfs(grid);\n                break;\n            default:\n              console.log(`There is no algorithm with this index`);\n          }\n        \n        console.log('visitedNodesInOrder => ', visitedNodesInOrder)\n\n        const nodesInShortestPathOrder = [];\n        let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\n\n        while (currentNode !== undefined) {\n            nodesInShortestPathOrder.push(currentNode);\n            currentNode = currentNode.previousNode;\n        }\n        animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    } else {\n        alert(\"Please define a finish node\");\n    }\n  } else {\n    alert(\"Please define a start node\");\n  }\n};\n\nconst animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n  for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n    if (i === visitedNodesInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(nodesInShortestPathOrder);\n      }, 10 * i);\n      return;\n    }\n    setTimeout(() => {\n      document.getElementById(\n        `node-${visitedNodesInOrder[i].row}-${visitedNodesInOrder[i].col}`\n      ).className = \"node node-visited\";\n    }, 10 * i);\n  }\n};\n\nconst animateShortestPath = (nodesInShortestPathOrder) => {\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    setTimeout(() => {\n      document.getElementById(\n        `node-${nodesInShortestPathOrder[i].row}-${nodesInShortestPathOrder[i].col}`\n      ).className = \"node node-shortest-path\";\n    }, 50 * i);\n  }\n};\n","import React, { useContext, useState } from 'react';\nimport './Pathfindings.scss'\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { visualizeAlgorithm } from '../../animations/AnimateAlgorithm';\n\nexport default function Pathfindings() {\n\n    const {\n        grid: [grid, ], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('PATH !');\n\n    const visualizeGo = (algorithm) => {\n      if (algorithm === 'PATH !'){\n        alert('Select a pathfinding algorithm');\n      }\n      if (algorithm === 'DIJKSTRA PATH !'){\n        visualizeAlgorithm(gridState, grid, 0);\n        setAlgorithm('PATH !');\n      }\n      if (algorithm === 'A* PATH !'){\n        visualizeAlgorithm(gridState, grid, 1);\n        setAlgorithm('PATH !');\n      }\n      if (algorithm === 'BFS PATH !'){\n        visualizeAlgorithm(gridState, grid, 2);\n        setAlgorithm('PATH !');\n      }\n    }\n\n    const selectAlgorithm = (algorithm) => {\n      switch(algorithm) {\n        case \"dijkstra\": { setAlgorithm('DIJKSTRA PATH !'); break; }\n        case \"astar\": { setAlgorithm('A* PATH !'); break; }\n        case \"greedy\": { setAlgorithm('GREEDY PATH !'); break; }\n        case \"bfs\": { setAlgorithm('BFS PATH !'); break; }\n        case \"dfs\": { setAlgorithm('DFS PATH !'); break; }\n        default: { break;}\n      }\n    }\n\n    return (\n      <div className='container'>\n        <div className=\"pathfindings\">\n          <span>Pathfinding algorithm</span>\n          <div className=\"options\">\n            <span onClick={()=>selectAlgorithm('dijkstra')}>Dijkstra's algorithm</span>\n            <span onClick={()=>selectAlgorithm('astar')}>A* algorithm</span>\n            <span onClick={()=>selectAlgorithm('greedy')}>Greedy algorithm</span>\n            <span onClick={()=>selectAlgorithm('bfs')}>Breadth-First Search algoriithm</span>\n            <span onClick={()=>selectAlgorithm('dfs')}>Depth-First Search algorithm</span>\n          </div>\n        </div>\n        <input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n      </div>\n    );\n}\n","//RANDOMIZED KRUSKAL ALGORITHM\nexport function kruskal(mazeMap) {\n    \n    const { maze } = mapToArray(mazeMap);\n\tconst openEdgesInOrder = [];\n\n    //Step 1 : make the edges set; \n        // an edge is a linear(to avoid saying diagonal) combinaison of three nodes, \n        // and is only 'perpendicularly' adjacent to others edges\n    let edges = setEdges(maze);\n\n    //Step 2 : While the set of edges is not empty\n    while (!!edges.length) {\n        //Randomly get an edge and remove it from the set\n        const index = getRandomInt(edges.length)\n        const edge = edges[index];\n        edges.splice(index, 1);\n        \n\n        //If cells are not already in the same bucket: Connect them\n        if (maze[edge.first.row][edge.first.col].kruskalID !== maze[edge.second.row][edge.second.col].kruskalID){\n            //merge edges in the maze\n            mergeKruskalGroup(edge, maze);\n            openEdgesInOrder.push(edge);\n        }\n    }\n    console.log(openEdgesInOrder)\n    console.log(maze)\n    return (openEdgesInOrder);\n}\n\nconst mergeKruskalGroup = (edge, maze) => {\n    const temp = maze[edge.first.row][edge.first.col].kruskalID;\n    maze[edge.center.row][edge.center.col].kruskalID = temp;\n\n    const secondGroup = maze[edge.second.row][edge.second.col].kruskalID;\n\n    for(let row of maze){\n        for(let node of row){\n            if (node.kruskalID === secondGroup){\n                node.kruskalID = temp;\n            }\n        }\n    }\n}\n\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nconst setEdges = (maze) => {\n    const rows = maze.length;\n    const cols = maze[0].length;\n\n    const edges = [];\n    for(let i=0; i<rows; i++){\n        for(let j=0; j<cols; j++){\n            const edge = {first: {}, center: {}, second: {}};\n            if(i%2 !== 0 && j%2 === 0){\n                edge.first = {...maze[i-1][j]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i+1][j]};\n\n                edges.push(edge);\n            }\n            if(i%2 === 0 && j%2 !== 0){\n                edge.first = {...maze[i][j-1]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i][j+1]};\n\n                edges.push(edge);\n            }\n        }\n    }\n    return edges;\n}\n\nconst mapToArray = (mazeMap) => {\n    const maze = [];\n\tconst cells = [];\n    let startNode = {};\n    let endNode = {};\n    let hasStart = false;\n    let hasEnd = false;\n\n    let key = 0;\n    for(let row of mazeMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n\n            currentRow.push({...node, kruskalID: key});\n\t\t\tcells.push({...node, kruskalID: key}); \n            key = key + 1;\n\n            if(node.isStart){\n\t\t\t\thasStart = true;\n                startNode = {...node};\n            }\n            if(node.isEnd){\n                hasEnd = true;\n                endNode = {...node};\n            }\n        }\n        maze.push(currentRow);\n\t}\n    return {maze: maze, cells: cells, startNode: startNode, endNode: endNode, hasStart: hasStart, hasEnd: hasEnd};\n}\n","import React, { useContext, useState } from 'react';\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { kruskal } from '../../../utils/kruskal';\n\nexport default function Mazes() {\n\n\tconst {\n        grid: [grid, setGrid], \n        gridState: [ gridState,  setGridState]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('MAZE !');\n\n\tconst visualizeGo = (algorithm) => {\n\t\tif (algorithm === 'MAZE !'){\n\t\t  alert('Select a maze algorithm');\n\t\t}\n\t\tif (algorithm === 'KRUSKAL MAZE !'){\n\t\t  visualizeKruskal();\n\t\t  setAlgorithm('MAZE !');\n\t\t}\n\t  }\n\n    const selectAlgorithm = (algorithm) => {\n        switch(algorithm) {\n          case \"kruskal\": { setAlgorithm('KRUSKAL MAZE !'); break; }\n          case \"prim\": { setAlgorithm('PRIM MAZE !'); break; }\n          case \"wilson\": { setAlgorithm('WILSON MAZE !'); break; }\n          case \"aldous\": { setAlgorithm('ALDOUS-BRODER MAZE !'); break; }\n          default: { break;}\n        }\n    }\n\n\tconst visualizeKruskal = () => {\n\t\tconst openEdgesInOrder = kruskal(grid);\n\n\t\t//Put all nodes to wall mode\n\t\tfor(let [rowkey, row] of grid.entries()){\n\t\t\tfor(let [nodekey, node] of row.entries()){\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true,})) );\n\t\t\t\tsetGridState({...gridState, hasWall: true});\n\t\t\t}\n\t\t}\n\n\t\tfor (let openEdge of openEdgesInOrder) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdge.center.row, new Map(prev.get(openEdge.center.row))\n\t\t\t\t\t\t\t.set(openEdge.center.col, {...openEdge.center, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdge.first.row, new Map(prev.get(openEdge.first.row))\n\t\t\t\t\t\t\t.set(openEdge.first.col, {...openEdge.first, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdge.second.row, new Map(prev.get(openEdge.second.row))\n\t\t\t\t\t\t\t.set(openEdge.second.col, {...openEdge.second, isWall: false,})) );\n\t\t\t}, 5)\n\t\t}\n\t}\n\t\n\n\treturn (\n\t\t<div className=\"container\">\n\t\t\t<div className=\"mazes\">\n\t\t\t\t<span>Maze algorithm</span>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('kruskal')}>Kruskal's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('prim')}>Prim's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('wilson')}>Wilson's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('aldous')}>Aldous-Broder algorithm</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n\t\t</div>\n\t);\n}\n","import React from 'react'\nimport './NavBar.scss'\nimport ReactTooltip from 'react-tooltip';\nimport Reset from './icons/Reset';\nimport Help from './icons/Help';\nimport Pathfindings from './pathfindings/Pathfindings';\nimport Mazes from './mazes/Mazes';\n\nexport default function NavBar() {\n\n    return (\n        <div className='navbar'>\n            <div className=\"container\">\n\t\t\t\t<div className=\"left\">\n\t\t\t\t\t<div className=\"logo\">\n\t\t\t\t\t\t<img src=\"https://cdn-icons-png.flaticon.com/512/182/182580.png\" alt=\"from flaticon\" />\n\t\t\t\t\t\t<span>Pathfinder</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Mazes/>\n          \t\t\t<Pathfindings/>\n\t\t\t\t</div>\n        <div className=\"right\">\n\t\t\t\t\t<Reset/>\n\t\t\t\t\t<Help/>\n\t\t\t\t\t<ReactTooltip className='tooltip-class' delayHide={500} place='bottom' effect='solid' globalEventOff=\"click\" />\n\t\t\t\t</div>\n\t\t\t</div>\n        </div>\n    )\n}\n","import React from 'react'\nimport Grid from '../components/grid/Grid'\nimport NavBar from '../components/navbar/NavBar'\nimport StoreProvider from '../utils/StoreProvider'\nimport './Home.scss'\n\nexport default function home() {\n    return (\n        <StoreProvider>\n            <div className='home'>\n                <NavBar/>\n                <Grid/>\n            </div>\n        </StoreProvider>\n    )\n}\n","import './App.scss';\nimport Home from './home/Home';\n\nfunction App() {\n  return (\n    <div>\n      <Home/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}