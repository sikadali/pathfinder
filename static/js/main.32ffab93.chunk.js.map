{"version":3,"sources":["components/grid/node/Node.jsx","utils/StoreProvider.js","components/grid/Grid.jsx","components/navbar/icons/Reset.jsx","components/navbar/icons/Help.jsx","utils/dijkstra.js","components/navbar/pathfindings/Pathfindings.jsx","utils/kruskal.js","components/navbar/mazes/Mazes.jsx","components/navbar/NavBar.jsx","home/Home.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","row","col","isEnd","isStart","nodeStateClass","isWall","id","className","onContextMenu","onClick","StoreContext","React","createContext","StoreProvider","children","useState","Map","grid","setGrid","gridState","setGridState","useEffect","g","map","i","currentRow","j","set","getInitialGrid","hasStart","hasEnd","store","Provider","value","Grid","useContext","entries","rowkey","nodekey","node","prev","get","defineNode","e","preventDefault","clearNode","Reset","childToParent","Help","mapToArray","gridMap","nodes","startNode","endNode","values","push","distance","isVisited","Number","POSITIVE_INFINITY","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","element","neighbor","previousNode","neighbors","length","filter","Pathfindings","algorithm","setAlgorithm","selectAlgorithm","visualizeDijkstra","visitedNodesInOrder","closestNode","shift","dijkstra","nodesInShortestPathOrder","currentNode","undefined","animateDijkstra","alert","setTimeout","animateShortestPath","document","getElementById","type","visualizeGo","mergeKruskalGroup","edge","maze","temp","first","kruskalID","center","secondGroup","second","setEdges","rows","cols","edges","mazeMap","cells","key","Mazes","visualizeKruskal","openEdgesInOrder","max","index","Math","floor","random","splice","console","log","kruskal","NavBar","src","alt","delayHide","place","effect","globalEventOff","home","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.32ffab93.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nexport const Node = (props) => {\n\tconst { row, col, isEnd, isStart, isWall} = props;\n\tconst nodeStateClass = isWall ? 'wall' : isStart ? 'start' : isEnd ? 'end' : '';\n\n\treturn (\n\t\t<div\n\t\t\tid={`node-${row}-${col}`}\n\t\t\tclassName={`node ${nodeStateClass}`}\n\t\t\tonContextMenu={props.onContextMenu}\n\t\t\tonClick={props.onClick}\n\t\t/>\n\t);\n};\n","import React, { useState, useEffect } from 'react';\n\nconst TOTAL_ROW = 29;\nconst TOTAL_COL = 61;\n\nexport const StoreContext = React.createContext(null);\n\nconst StoreProvider = ({ children }) => {\n\n    //Data for grid management\n\tconst [grid, setGrid] = useState(new Map());\n    //Data for node state management\n    const [gridState, setGridState] = useState({});\n    \n    const getInitialGrid = () => {\n\t\tconst map = new Map();\n\t\tfor (let i = 0; i < TOTAL_ROW; i++) {\n\t\t\tconst currentRow = new Map();\n\t\t\tfor (let j = 0; j < TOTAL_COL; j++) {\n\t\t\t\tcurrentRow.set(j, { row: i, col: j, isStart: false, isWall: false, isEnd: false});\n\t\t\t}\n\t\t\tmap.set(i, new Map(currentRow));\n\t\t}\n\t\treturn (map);\n\t}\n\tuseEffect(() => {\n\t\tconst g = getInitialGrid();\n\t\tsetGrid(g);\n        setGridState({hasStart: false, hasEnd: false});\n\t}, [])\n\n    \n\n\tconst store = {\n\t\tgrid: [ grid, setGrid ],\n        gridState: [ gridState, setGridState ]\n\t};\n\n\treturn( \n        <StoreContext.Provider value={store}>\n            {children}\n        </StoreContext.Provider>\n    );\n};\nexport default StoreProvider;","import React, { useContext } from 'react'\nimport './Grid.scss'\nimport { Node } from './node/Node'\nimport { StoreContext } from '../../utils/StoreProvider';\n\n\nexport default function Grid() {\n\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n    const defineNode = (rowkey, nodekey, node) => {\n        if(gridState.hasStart) {\n            if(gridState.hasEnd) {\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true, isEnd: false, isStart: false})) );\n            }\n            else{\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: true, isStart: false})) );\n                setGridState({...gridState, hasEnd: true});\n            }\n        }\n        else {\n            setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: true})) );\n            setGridState({...gridState, hasStart: true});\n        }        \n\t};\n\n    const clearNode = (rowkey, nodekey, node) => {\n        if(node.isStart){\n            setGridState({...gridState, hasStart: false});\n        }\n        if(node.isEnd){\n            setGridState({...gridState, hasEnd: false});\n        }\n\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: false})) );\n\t};\n\n    return (\n        <div className=\"grid\">\n\t\t\t{[...grid.entries()].map(([rowkey, row]) => {\n\t\t\t\treturn(\n\t\t\t\t\t<div key={rowkey} className=\"grid_rows\">\n\t\t\t\t\t\t{[...row.entries()].map( ([nodekey, node]) => {\n\t\t\t\t\t\t\tconst {row, col, isWall, isEnd, isStart} = node;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Node \n\t\t\t\t\t\t\t\t\tkey={nodekey} \n\t\t\t\t\t\t\t\t\trow={row} \n                                    col={col}\n                                    isWall={isWall} \n\t\t\t\t\t\t\t\t\tisEnd={isEnd}\n\t\t\t\t\t\t\t\t\tisStart={isStart}\n                                    onClick={()=>defineNode(rowkey, nodekey, node)}\n                                    onContextMenu={(e) => {\n                                        e.preventDefault();\n                                        clearNode(rowkey, nodekey, node);\n                                    }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t</div>\n    )\n}\n","import React from 'react'\nimport RotateLeftIcon from '@material-ui/icons/RotateLeft';\n\nexport default function Reset({childToParent}) {\n    return (\n        <div>\n            <RotateLeftIcon className=\"icon\" data-tip=\"Reset\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","import React from 'react'\nimport HelpOutlineIcon from '@material-ui/icons/HelpOutline';\n\nexport default function Help({childToParent}) {\n    return (\n        <div>\n            <HelpOutlineIcon className=\"icon\" data-tip=\"Help\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(gridMap) {\n    const {grid, nodes, endNode} = mapToArray(gridMap);\n\tconst visitedNodesInOrder = [];\n\n\twhile (!!nodes.length) { // '!!' to convert length of unvisited nodes to boolean true since it reaches 0 and begin false\n\t\tsortNodesByDistance(nodes);\n\t\tconst closestNode = nodes.shift();\n\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue\n\t\t}\n\t\t// If the closest node is at a distance of infinity, we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === 1000) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\n\t\tif (closestNode.row === endNode.row && closestNode.col === endNode.col) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\t\tupdateUnvisitedNeighbors(closestNode, grid, nodes);\n\t}\n\t\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node};\n\t\t\t\tcurrentRow.push({...node, distance: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => {return(nodeA.distance - nodeB.distance)});\n}\n\nconst updateUnvisitedNeighbors = (node, grid, nodes) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const element of nodes) {\n\t\tfor(const neighbor of unvisitedNeighbors){\n\t\t\tif(neighbor.row === element.row && neighbor.col === element.col){\n\t\t\t\telement.distance = node.distance + 1;\n\t\t\t\telement.previousNode = node;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors.filter(neighbor => !neighbor.isVisited)\n\t);\n}","import React, { useContext, useState } from 'react';\nimport './Pathfindings.scss'\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { dijkstra } from '../../../utils/dijkstra';\n\nexport default function Pathfindings() {\n\n    const {\n        grid: [grid, ], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('PATH !');\n\n    const visualizeGo = (algorithm) => {\n      if (algorithm === 'PATH !'){\n        alert('Select a pathfinding algorithm');\n      }\n      if (algorithm === 'DIJKSTRA PATH !'){\n        visualizeDijkstra();\n        setAlgorithm('PATH !');\n      }\n    }\n\n    const selectAlgorithm = (algorithm) => {\n      switch(algorithm) {\n        case \"dijkstra\": { setAlgorithm('DIJKSTRA PATH !'); break; }\n        case \"astar\": { setAlgorithm('A* PATH !'); break; }\n        case \"greedy\": { setAlgorithm('GREEDY PATH !'); break; }\n        case \"bfs\": { setAlgorithm('BFS PATH !'); break; }\n        case \"dfs\": { setAlgorithm('DFS PATH !'); break; }\n        default: { break;}\n      }\n    }\n\n    const visualizeDijkstra = () => {\n        if(gridState.hasStart){\n          if(gridState.hasEnd){\n            const visitedNodesInOrder = dijkstra(grid);\n\n            const nodesInShortestPathOrder = [];\n            let currentNode = visitedNodesInOrder[visitedNodesInOrder.length-1];\n            \n            while (currentNode !== undefined) {\n              nodesInShortestPathOrder.push(currentNode);\n              currentNode = currentNode.previousNode;\n            }\n            animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n\n          }else{\n            alert('Please define a finish node')\n          }\n        }\n        else{\n          alert('Please define a start node')\n        }\n    }\n\n    const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n          if (i === visitedNodesInOrder.length) {\n            setTimeout(() => {\n              animateShortestPath(nodesInShortestPathOrder);\n            }, 10 * i);\n            return;\n          }\n          setTimeout(() => {\n            document.getElementById(`node-${visitedNodesInOrder[i].row}-${visitedNodesInOrder[i].col}`).className =\n              'node node-visited';\n          }, 10 * i);\n        }\n    }\n    \n    const animateShortestPath = (nodesInShortestPathOrder) => {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n          setTimeout(() => {\n            //const node = nodesInShortestPathOrder[i];\n            document.getElementById(`node-${nodesInShortestPathOrder[i].row}-${nodesInShortestPathOrder[i].col}`).className =\n              'node node-shortest-path';\n          }, 50 * i);\n        }\n    }\n\n\treturn (\n\t\t<div className='container'>\n\t\t\t<div className=\"pathfindings\">\n\t\t\t\t<span>Pathfinding algorithm</span>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('dijkstra')}>Dijkstra's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('astar')}>A* algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('greedy')}>Greedy algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('bfs')}>Breadth-First Search algoriithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('dfs')}>Depth-First Search algorithm</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n\t\t</div>\n\t);\n}\n","//RANDOMIZED KRUSKAL ALGORITHM : essayer la version avec la moitie des cellules deja ouvertes !!!!!\nexport function kruskal(mazeMap) {\n    \n    const {maze, cells, startNode, endNode, hasStart, hasEnd} = mapToArray(mazeMap);\n\tconst openEdgesInOrder = [];\n\n    //Step 1 : make the edges set; \n        //an edge is a linear(to say not diagonal) combinaison of three nodes, and is only 'perpendicularly' adjacent to others edges\n    let edges = setEdges(maze);\n\n    //Step 2 : While the set of edges is not empty\n    while (!!edges.length) {\n        //Randomly get an edge and remove it from the set\n        const index = getRandomInt(edges.length)\n        const edge = edges[index];\n        edges.splice(index, 1);\n        \n\n        //If cells are not already in the same bucket: Connect them !!!PROBLEM HERE!!!\n        if (maze[edge.first.row][edge.first.col].kruskalID !== maze[edge.second.row][edge.second.col].kruskalID){\n            //merge edges in the maze\n            mergeKruskalGroup(edge, maze);\n            openEdgesInOrder.push(edge);\n        }\n    }\n\n\n    console.log(openEdgesInOrder)\n    console.log(maze)\n    return (openEdgesInOrder);\n}\n\nconst mergeKruskalGroup = (edge, maze) => {\n    const temp = maze[edge.first.row][edge.first.col].kruskalID;\n    maze[edge.center.row][edge.center.col].kruskalID = temp;\n\n    const secondGroup = maze[edge.second.row][edge.second.col].kruskalID;\n\n    for(let row of maze){\n        for(let node of row){\n            if (node.kruskalID === secondGroup){\n                node.kruskalID = temp;\n            }\n        }\n    }\n}\n\n// export function kruskalTwo(mazeMap) {\n    \n//     const {maze, cells, startNode, endNode, hasStart, hasEnd} = mapToArray(mazeMap);\n// \tconst openEdgesInOrder = [];\n\n//     openEveryOtherCell(maze);\n// \tconst numIterations = (maze.length - 1) * (maze[0].length + 3) / 4;\n// \tfor (let i = 0; i < numIterations; i++) {\n// \t\titerateKruskal();\n// \t}\n\n// }\n\n// const iterateKruskal = () => {\n// }\n// const openEveryOtherCell = () => {\n// }\n\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction shuffle(array) {\n    let currentIndex = array.length, temporaryValue, randomIndex;\n  \n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n  \n    return array;\n}\n\n\nconst setEdges = (maze) => {\n    const rows = maze.length;\n    const cols = maze[0].length;\n\n    const edges = [];\n    for(let i=0; i<rows; i++){\n        for(let j=0; j<cols; j++){\n            const edge = {first: {}, center: {}, second: {}};\n            if(i%2 !== 0 && j%2 === 0){\n                edge.first = {...maze[i-1][j]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i+1][j]};\n\n                edges.push(edge);\n            }\n            if(i%2 === 0 && j%2 !== 0){\n                edge.first = {...maze[i][j-1]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i][j+1]};\n\n                edges.push(edge);\n            }\n        }\n    }\n    return edges;\n}\n\nconst mapToArray = (mazeMap) => {\n    const maze = [];\n\tconst cells = [];\n    let startNode = {};\n    let endNode = {};\n    let hasStart = false;\n    let hasEnd = false;\n\n    let key = 0;\n    for(let row of mazeMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n\n            currentRow.push({...node, kruskalID: key});\n\t\t\tcells.push({...node, kruskalID: key}); \n            key = key + 1;\n\n            if(node.isStart){\n\t\t\t\thasStart = true;\n                startNode = {...node};\n            }\n            if(node.isEnd){\n                hasEnd = true;\n                endNode = {...node};\n            }\n        }\n        maze.push(currentRow);\n\t}\n    return {maze: maze, cells: cells, startNode: startNode, endNode: endNode, hasStart: hasStart, hasEnd: hasEnd};\n}\n","import React, { useContext, useState } from 'react';\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { kruskal } from '../../../utils/kruskal';\n\nexport default function Mazes() {\n\n\tconst {\n        grid: [grid, setGrid], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('MAZE !');\n\n\tconst visualizeGo = (algorithm) => {\n\t\tif (algorithm === 'MAZE !'){\n\t\t  alert('Select a maze algorithm');\n\t\t}\n\t\tif (algorithm === 'KRUSKAL MAZE !'){\n\t\t  visualizeKruskal();\n\t\t  setAlgorithm('MAZE !');\n\t\t}\n\t  }\n\n    const selectAlgorithm = (algorithm) => {\n        switch(algorithm) {\n          case \"kruskal\": { setAlgorithm('KRUSKAL MAZE !'); break; }\n          case \"prim\": { setAlgorithm('PRIM MAZE !'); break; }\n          case \"wilson\": { setAlgorithm('WILSON MAZE !'); break; }\n          case \"aldous\": { setAlgorithm('ALDOUS-BRODER MAZE !'); break; }\n          default: { break;}\n        }\n    }\n\n\tconst visualizeKruskal = () => {\n\t\tconst openEdgesInOrder = kruskal(grid);\n\n\t\t//Put all nodes to wall mode\n\t\tfor(let [rowkey, row] of grid.entries()){\n\t\t\tfor(let [nodekey, node] of row.entries()){\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true,})) );\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < openEdgesInOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].center.row, new Map(prev.get(openEdgesInOrder[i].center.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].center.col, {...openEdgesInOrder[i].center, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].first.row, new Map(prev.get(openEdgesInOrder[i].first.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].first.col, {...openEdgesInOrder[i].first, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].second.row, new Map(prev.get(openEdgesInOrder[i].second.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].second.col, {...openEdgesInOrder[i].second, isWall: false,})) );\n\t\t\t}, 5)\n\t\t}\n\t}\n\t\n\n\treturn (\n\t\t<div className=\"container\">\n\t\t\t<div className=\"mazes\">\n\t\t\t\t<span>Maze algorithm</span>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('kruskal')}>Kruskal's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('prim')}>Prim's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('wilson')}>Wilson's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('aldous')}>Aldous-Broder algorithm</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n\t\t</div>\n\t);\n}\n","import React from 'react'\nimport './NavBar.scss'\nimport ReactTooltip from 'react-tooltip';\nimport Reset from './icons/Reset';\nimport Help from './icons/Help';\nimport Pathfindings from './pathfindings/Pathfindings';\nimport Mazes from './mazes/Mazes';\n\nexport default function NavBar() {\n\n    return (\n        <div className='navbar'>\n            <div className=\"container\">\n\t\t\t\t<div className=\"left\">\n\t\t\t\t\t<div className=\"logo\">\n\t\t\t\t\t\t<img src=\"https://cdn-icons-png.flaticon.com/512/182/182580.png\" alt=\"from flaticon\" />\n\t\t\t\t\t\t<span>Pathfinder</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Mazes/>\n          \t\t\t<Pathfindings/>\n\t\t\t\t</div>\n        <div className=\"right\">\n\t\t\t\t\t<Reset/>\n\t\t\t\t\t<Help/>\n\t\t\t\t\t<ReactTooltip className='tooltip-class' delayHide={500} place='bottom' effect='solid' globalEventOff=\"click\" />\n\t\t\t\t</div>\n\t\t\t</div>\n        </div>\n    )\n}\n","import React from 'react'\nimport Grid from '../components/grid/Grid'\nimport NavBar from '../components/navbar/NavBar'\nimport StoreProvider from '../utils/StoreProvider'\nimport './Home.scss'\n\nexport default function home() {\n    return (\n        <StoreProvider>\n            <div className='home'>\n                <NavBar/>\n                <Grid/>\n            </div>\n        </StoreProvider>\n    )\n}\n","import './App.scss';\nimport Home from './home/Home';\n\nfunction App() {\n  return (\n    <div>\n      <Home/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}