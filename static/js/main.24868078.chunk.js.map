{"version":3,"sources":["components/grid/node/Node.jsx","utils/StoreProvider.js","components/grid/Grid.jsx","components/navbar/icons/Reset.jsx","components/navbar/icons/Help.jsx","utils/dijkstra.js","components/animations/Dijkstra.js","utils/astar.js","components/animations/Astar.js","components/navbar/pathfindings/Pathfindings.jsx","utils/kruskal.js","components/navbar/mazes/Mazes.jsx","components/navbar/NavBar.jsx","home/Home.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","row","col","isEnd","isStart","nodeStateClass","isWall","id","className","onContextMenu","onClick","StoreContext","React","createContext","StoreProvider","children","useState","Map","grid","setGrid","gridState","setGridState","useEffect","g","map","i","currentRow","j","set","getInitialGrid","hasStart","hasEnd","store","Provider","value","Grid","useContext","entries","rowkey","nodekey","node","prev","get","defineNode","e","preventDefault","clearNode","Reset","childToParent","Help","mapToArray","gridMap","nodes","startNode","endNode","values","push","distance","isVisited","Number","POSITIVE_INFINITY","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","updateUnvisitedNeighbors","unvisitedNeighbors","getUnvisitedNeighbors","element","neighbor","previousNode","neighbors","length","filter","visualizeDijkstra","visitedNodesInOrder","closestNode","shift","dijkstra","console","log","nodesInShortestPathOrder","currentNode","undefined","animateAlgorithm","alert","setTimeout","animateShortestPath","document","getElementById","cost","heuristic","f","getNeighbors","sortOpenListByF","openList","insideList","list","heuristicManhattan","Math","abs","visualizeAstar","closedList","costNode","costNodeIsBest","astar","Pathfindings","algorithm","setAlgorithm","selectAlgorithm","type","visualizeGo","mergeKruskalGroup","edge","maze","temp","first","kruskalID","center","secondGroup","second","setEdges","rows","cols","edges","mazeMap","cells","key","Mazes","visualizeKruskal","openEdgesInOrder","max","index","floor","random","splice","kruskal","NavBar","src","alt","delayHide","place","effect","globalEventOff","home","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.24868078.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nexport const Node = (props) => {\n\tconst { row, col, isEnd, isStart, isWall} = props;\n\tconst nodeStateClass = isWall ? 'wall' : isStart ? 'start' : isEnd ? 'end' : '';\n\n\treturn (\n\t\t<div\n\t\t\tid={`node-${row}-${col}`}\n\t\t\tclassName={`node ${nodeStateClass}`}\n\t\t\tonContextMenu={props.onContextMenu}\n\t\t\tonClick={props.onClick}\n\t\t/>\n\t);\n};\n","import React, { useState, useEffect } from 'react';\n\nconst TOTAL_ROW = 29;\nconst TOTAL_COL = 61;\n\nexport const StoreContext = React.createContext(null);\n\nconst StoreProvider = ({ children }) => {\n\n    //Data for grid management\n\tconst [grid, setGrid] = useState(new Map());\n    //Data for node state management\n    const [gridState, setGridState] = useState({});\n    \n    const getInitialGrid = () => {\n\t\tconst map = new Map();\n\t\tfor (let i = 0; i < TOTAL_ROW; i++) {\n\t\t\tconst currentRow = new Map();\n\t\t\tfor (let j = 0; j < TOTAL_COL; j++) {\n\t\t\t\tcurrentRow.set(j, { row: i, col: j, isStart: false, isWall: false, isEnd: false});\n\t\t\t}\n\t\t\tmap.set(i, new Map(currentRow));\n\t\t}\n\t\treturn (map);\n\t}\n\tuseEffect(() => {\n\t\tconst g = getInitialGrid();\n\t\tsetGrid(g);\n        setGridState({hasStart: false, hasEnd: false});\n\t}, [])\n\n    \n\n\tconst store = {\n\t\tgrid: [ grid, setGrid ],\n        gridState: [ gridState, setGridState ]\n\t};\n\n\treturn( \n        <StoreContext.Provider value={store}>\n            {children}\n        </StoreContext.Provider>\n    );\n};\nexport default StoreProvider;","import React, { useContext } from 'react'\nimport './Grid.scss'\nimport { Node } from './node/Node'\nimport { StoreContext } from '../../utils/StoreProvider';\n\n\nconst Grid = () => {\n\n    const {\n        grid: [grid, setGrid], \n        gridState: [ gridState, setGridState ]\n      } = useContext(StoreContext);\n\n    const defineNode = (rowkey, nodekey, node) => {\n        if(gridState.hasStart) {\n            if(gridState.hasEnd) {\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true, isEnd: false, isStart: false})) );\n            }\n            else{\n                setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: true, isStart: false})) );\n                setGridState({...gridState, hasEnd: true});\n            }\n        }\n        else {\n            setGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: true})) );\n            setGridState({...gridState, hasStart: true});\n        }        \n\t};\n\n    const clearNode = (rowkey, nodekey, node) => {\n        if(node.isStart){\n            setGridState({...gridState, hasStart: false});\n        }\n        if(node.isEnd){\n            setGridState({...gridState, hasEnd: false});\n        }\n\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: false, isEnd: false, isStart: false})) );\n\t};\n\n    return (\n        <div className=\"grid\">\n\t\t\t{[...grid.entries()].map(([rowkey, row]) => {\n\t\t\t\treturn(\n\t\t\t\t\t<div key={rowkey} className=\"grid_rows\">\n\t\t\t\t\t\t{[...row.entries()].map( ([nodekey, node]) => {\n\t\t\t\t\t\t\tconst {row, col, isWall, isEnd, isStart} = node;\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Node \n\t\t\t\t\t\t\t\t\tkey={nodekey} \n\t\t\t\t\t\t\t\t\trow={row} \n                                    col={col}\n                                    isWall={isWall} \n\t\t\t\t\t\t\t\t\tisEnd={isEnd}\n\t\t\t\t\t\t\t\t\tisStart={isStart}\n                                    onClick={()=>defineNode(rowkey, nodekey, node)}\n                                    onContextMenu={(e) => {\n                                        e.preventDefault();\n                                        clearNode(rowkey, nodekey, node);\n                                    }}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t</div>\n    )\n}\n\nexport default Grid;","import React from 'react'\nimport RotateLeftIcon from '@material-ui/icons/RotateLeft';\n\nexport default function Reset({childToParent}) {\n    return (\n        <div>\n            <RotateLeftIcon className=\"icon\" data-tip=\"Reset\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","import React from 'react'\nimport HelpOutlineIcon from '@material-ui/icons/HelpOutline';\n\nexport default function Help({childToParent}) {\n    return (\n        <div>\n            <HelpOutlineIcon className=\"icon\" data-tip=\"Help\" onClick={() => childToParent()}/>\n        </div>\n    )\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(gridMap) {\n    const {grid, nodes, endNode} = mapToArray(gridMap);\n\tconst visitedNodesInOrder = [];\n\n\twhile (!!nodes.length) { // '!!' to convert length of unvisited nodes to boolean true since it reaches 0 and begin false\n\t\tsortNodesByDistance(nodes);\n\t\tconst closestNode = nodes.shift();\n\n\t\t// If we encounter a wall, we skip it.\n\t\tif (closestNode.isWall) {\n\t\t\tcontinue\n\t\t}\n\t\t// If the closest node is at a distance of infinity, we must be trapped and should therefore stop.\n\t\tif (closestNode.distance === 1000) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\n\t\tif (closestNode.row === endNode.row && closestNode.col === endNode.col) {\n\t\t\treturn (visitedNodesInOrder)\n\t\t}\n\t\tupdateUnvisitedNeighbors(closestNode, grid, nodes);\n\t}\n\t\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node};\n\t\t\t\tcurrentRow.push({...node, distance: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t\tnodes.push({...node, distance: Number.POSITIVE_INFINITY, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => {return(nodeA.distance - nodeB.distance)});\n}\n\nconst updateUnvisitedNeighbors = (node, grid, nodes) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const element of nodes) {\n\t\tfor(const neighbor of unvisitedNeighbors){\n\t\t\tif(neighbor.row === element.row && neighbor.col === element.col){\n\t\t\t\telement.distance = node.distance + 1;\n\t\t\t\telement.previousNode = node;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst getUnvisitedNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors.filter(neighbor => !neighbor.isVisited)\n\t);\n}","import { dijkstra } from \"../../utils/dijkstra\";\n\nexport const visualizeDijkstra = (gridState, grid) => {\n  if (gridState.hasStart) {\n    if (gridState.hasEnd) {\n      const visitedNodesInOrder = dijkstra(grid);\n      console.log('visitedNodesInOrder => ', visitedNodesInOrder)\n\n      const nodesInShortestPathOrder = [];\n      let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\n\n      while (currentNode !== undefined) {\n        nodesInShortestPathOrder.push(currentNode);\n        currentNode = currentNode.previousNode;\n      }\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    } else {\n      alert(\"Please define a finish node\");\n    }\n  } else {\n    alert(\"Please define a start node\");\n  }\n};\n\nconst animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n  for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n    if (i === visitedNodesInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(nodesInShortestPathOrder);\n      }, 10 * i);\n      return;\n    }\n    setTimeout(() => {\n      document.getElementById(\n        `node-${visitedNodesInOrder[i].row}-${visitedNodesInOrder[i].col}`\n      ).className = \"node node-visited\";\n    }, 10 * i);\n  }\n};\n\nconst animateShortestPath = (nodesInShortestPathOrder) => {\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    setTimeout(() => {\n      //const node = nodesInShortestPathOrder[i];\n      document.getElementById(\n        `node-${nodesInShortestPathOrder[i].row}-${nodesInShortestPathOrder[i].col}`\n      ).className = \"node node-shortest-path\";\n    }, 50 * i);\n  }\n};\n","export const astar = (gridMap) => {\n    const {grid, startNode, endNode} = mapToArray(gridMap);\n\tconst closedList = [];   //visitedNodesInOrder\n\n    const openList = [];\n    openList.push(startNode)\n\n    while (!!openList.length){\n        // take nodeU, the node from openList with the biggest heuristic (manhattan distance in this case)\n        sortOpenListByF(openList)\n        const currentNode = openList.shift()\n\n        // loop : for each neighbor of nodeU inside the grid\n        const neighbors = getNeighbors(currentNode, grid);\n        for(let neighbor of neighbors){\n            // if neighbor already been visited, or is a wall node, skip to the next neighbor\n            if ( insideList(neighbor, closedList) || neighbor.isWall ) {\n                continue\n            }\n\n            // the node cost is the shortest distance from start to current node, we need to check if\n            // the path we have arrived at this neighbor is the shortest one we have seen yet\n            var costNode = currentNode.cost + 1; // 1 is the distance from a node to its neighbor\n            var costNodeIsBest = false;\n    \n    \n            if( !insideList(neighbor, openList) ) {\n                // This the the first time we have arrived at this node, it must be the best\n                // Also, we need to take the h (heuristic) score since we haven't done so yet\n                costNodeIsBest = true;\n                neighbor.heuristic = heuristicManhattan(neighbor, endNode);\n                openList.push(neighbor);\n            }\n            else if(costNode < neighbor.cost) {\n                // We have already seen the node, but last time it had a worse cost (distance from start)\n                costNodeIsBest = true;\n            }\n    \n            if(costNodeIsBest) {\n                // Found an optimal (so far) path to this node.  Store info on how we got here and\n                // just how good it really is...\n                neighbor.previousNode = currentNode;\n                neighbor.cost = costNode;\n                neighbor.f = neighbor.cost + neighbor.heuristic;\n            }\n        }\n        currentNode.isVisited = true; //after, try to comment this line\n        closedList.push(currentNode)\n\n        // if the node taken is the endNode then END\n        if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n\t\t\treturn (closedList)\n\t\t}\n    }\n    // end program (with error)\n    console.log(\"ERROR: A* not giving results\")\n    // inspired from https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/\n}\n\nconst mapToArray = (gridMap) => {\n    const grid = [];\n\tconst nodes = [];\n    let startNode = {};\n    let endNode = {};\n\n    for(let row of gridMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n            if(node.isStart){\n                startNode = {...node, cost: 0, heuristic: 0, f: 0, isVisited: false};\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n            }\n\t\t\telse{\n\t\t\t\tcurrentRow.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t\tnodes.push({...node, cost: 0, heuristic: 0, f: 0, isVisited: false});\n\t\t\t}\n\n            if(node.isEnd){\n                endNode = {...node};\n            }\n        }\n        grid.push(currentRow);\n\t}\n    return {grid: grid, nodes: nodes, startNode: startNode, endNode: endNode};\n}\n\nconst getNeighbors = (node, grid) => {\n    const neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) {  //down\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\tif (row < grid.length - 1) { //up\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\tif (col > 0) { //left\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\tif (col < grid[0].length - 1) { //right\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\treturn (\n\t\tneighbors //.filter(neighbor => !neighbor.isVisited)\n\t);\n}\n\nconst sortOpenListByF = (openList) => {\n    openList.sort((nodeA, nodeB) => {return(nodeA.f - nodeB.f)});\n}\n\nconst insideList = (neighbor, list) => {\n    for (let node of list) {\n        if (node.row === neighbor.row && node.col === neighbor.col) {\n            return true\n        }\n    }\n    return false\n}\n\nconst heuristicManhattan = (nodeA, nodeB) => {\n    // This is the Manhattan distance\n    var d1 = Math.abs (nodeB.row - nodeA.row);\n    var d2 = Math.abs (nodeB.col - nodeA.col);\n    return d1 + d2;\n}","import { astar } from \"../../utils/astar\";\n\nexport const visualizeAstar = (gridState, grid) => {\n  if (gridState.hasStart) {\n    if (gridState.hasEnd) {\n      const visitedNodesInOrder = astar(grid);\n      console.log('visitedNodesInOrder => ', visitedNodesInOrder)\n\n      const nodesInShortestPathOrder = [];\n      let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\n\n      while (currentNode !== undefined) {\n        nodesInShortestPathOrder.push(currentNode);\n        currentNode = currentNode.previousNode;\n      }\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    } else {\n      alert(\"Please define a finish node\");\n    }\n  } else {\n    alert(\"Please define a start node\");\n  }\n};\n\nconst animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n  for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n    if (i === visitedNodesInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(nodesInShortestPathOrder);\n      }, 10 * i);\n      return;\n    }\n    setTimeout(() => {\n      document.getElementById(\n        `node-${visitedNodesInOrder[i].row}-${visitedNodesInOrder[i].col}`\n      ).className = \"node node-visited\";\n    }, 10 * i);\n  }\n};\n\nconst animateShortestPath = (nodesInShortestPathOrder) => {\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    setTimeout(() => {\n      document.getElementById(\n        `node-${nodesInShortestPathOrder[i].row}-${nodesInShortestPathOrder[i].col}`\n      ).className = \"node node-shortest-path\";\n    }, 50 * i);\n  }\n};\n","import React, { useContext, useState } from 'react';\nimport './Pathfindings.scss'\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { visualizeDijkstra } from '../../animations/Dijkstra';\nimport { visualizeAstar } from '../../animations/Astar'; // maybe try to merge these two animations .js\n\nexport default function Pathfindings() {\n\n    const {\n        grid: [grid, ], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('PATH !');\n\n    const visualizeGo = (algorithm) => {\n      if (algorithm === 'PATH !'){\n        alert('Select a pathfinding algorithm');\n      }\n      if (algorithm === 'DIJKSTRA PATH !'){\n        visualizeDijkstra(gridState, grid);\n        setAlgorithm('PATH !');\n      }\n      if (algorithm === 'A* PATH !'){\n        visualizeAstar(gridState, grid);\n        setAlgorithm('PATH !');\n      }\n    }\n\n    const selectAlgorithm = (algorithm) => {\n      switch(algorithm) {\n        case \"dijkstra\": { setAlgorithm('DIJKSTRA PATH !'); break; }\n        case \"astar\": { setAlgorithm('A* PATH !'); break; }\n        case \"greedy\": { setAlgorithm('GREEDY PATH !'); break; }\n        case \"bfs\": { setAlgorithm('BFS PATH !'); break; }\n        case \"dfs\": { setAlgorithm('DFS PATH !'); break; }\n        default: { break;}\n      }\n    }\n\n    return (\n      <div className='container'>\n        <div className=\"pathfindings\">\n          <span>Pathfinding algorithm</span>\n          <div className=\"options\">\n            <span onClick={()=>selectAlgorithm('dijkstra')}>Dijkstra's algorithm</span>\n            <span onClick={()=>selectAlgorithm('astar')}>A* algorithm</span>\n            <span onClick={()=>selectAlgorithm('greedy')}>Greedy algorithm</span>\n            <span onClick={()=>selectAlgorithm('bfs')}>Breadth-First Search algoriithm</span>\n            <span onClick={()=>selectAlgorithm('dfs')}>Depth-First Search algorithm</span>\n          </div>\n        </div>\n        <input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n      </div>\n    );\n}\n","//RANDOMIZED KRUSKAL ALGORITHM : essayer la version avec la moitie des cellules deja ouvertes !!!!!\nexport function kruskal(mazeMap) {\n    \n    const {maze, cells, startNode, endNode, hasStart, hasEnd} = mapToArray(mazeMap);\n\tconst openEdgesInOrder = [];\n\n    //Step 1 : make the edges set; \n        //an edge is a linear(to say not diagonal) combinaison of three nodes, and is only 'perpendicularly' adjacent to others edges\n    let edges = setEdges(maze);\n\n    //Step 2 : While the set of edges is not empty\n    while (!!edges.length) {\n        //Randomly get an edge and remove it from the set\n        const index = getRandomInt(edges.length)\n        const edge = edges[index];\n        edges.splice(index, 1);\n        \n\n        //If cells are not already in the same bucket: Connect them !!!PROBLEM HERE!!!\n        if (maze[edge.first.row][edge.first.col].kruskalID !== maze[edge.second.row][edge.second.col].kruskalID){\n            //merge edges in the maze\n            mergeKruskalGroup(edge, maze);\n            openEdgesInOrder.push(edge);\n        }\n    }\n    console.log(openEdgesInOrder)\n    console.log(maze)\n    return (openEdgesInOrder);\n}\n\nconst mergeKruskalGroup = (edge, maze) => {\n    const temp = maze[edge.first.row][edge.first.col].kruskalID;\n    maze[edge.center.row][edge.center.col].kruskalID = temp;\n\n    const secondGroup = maze[edge.second.row][edge.second.col].kruskalID;\n\n    for(let row of maze){\n        for(let node of row){\n            if (node.kruskalID === secondGroup){\n                node.kruskalID = temp;\n            }\n        }\n    }\n}\n\n\nfunction getRandomInt(max) {\n    return Math.floor(Math.random() * max);\n}\n\nfunction shuffle(array) {\n    let currentIndex = array.length, temporaryValue, randomIndex;\n  \n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n  \n    return array;\n}\n\n\nconst setEdges = (maze) => {\n    const rows = maze.length;\n    const cols = maze[0].length;\n\n    const edges = [];\n    for(let i=0; i<rows; i++){\n        for(let j=0; j<cols; j++){\n            const edge = {first: {}, center: {}, second: {}};\n            if(i%2 !== 0 && j%2 === 0){\n                edge.first = {...maze[i-1][j]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i+1][j]};\n\n                edges.push(edge);\n            }\n            if(i%2 === 0 && j%2 !== 0){\n                edge.first = {...maze[i][j-1]};\n                edge.center = {...maze[i][j]};\n                edge.second = {...maze[i][j+1]};\n\n                edges.push(edge);\n            }\n        }\n    }\n    return edges;\n}\n\nconst mapToArray = (mazeMap) => {\n    const maze = [];\n\tconst cells = [];\n    let startNode = {};\n    let endNode = {};\n    let hasStart = false;\n    let hasEnd = false;\n\n    let key = 0;\n    for(let row of mazeMap.values()){\n        const currentRow = [];\n        for(let node of row.values()){\n\n            currentRow.push({...node, kruskalID: key});\n\t\t\tcells.push({...node, kruskalID: key}); \n            key = key + 1;\n\n            if(node.isStart){\n\t\t\t\thasStart = true;\n                startNode = {...node};\n            }\n            if(node.isEnd){\n                hasEnd = true;\n                endNode = {...node};\n            }\n        }\n        maze.push(currentRow);\n\t}\n    return {maze: maze, cells: cells, startNode: startNode, endNode: endNode, hasStart: hasStart, hasEnd: hasEnd};\n}\n","import React, { useContext, useState } from 'react';\nimport { StoreContext } from '../../../utils/StoreProvider';\nimport { kruskal } from '../../../utils/kruskal';\n\nexport default function Mazes() {\n\n\tconst {\n        grid: [grid, setGrid], \n        gridState: [ gridState,  ]\n      } = useContext(StoreContext);\n    const [algorithm, setAlgorithm] = useState('MAZE !');\n\n\tconst visualizeGo = (algorithm) => {\n\t\tif (algorithm === 'MAZE !'){\n\t\t  alert('Select a maze algorithm');\n\t\t}\n\t\tif (algorithm === 'KRUSKAL MAZE !'){\n\t\t  visualizeKruskal();\n\t\t  setAlgorithm('MAZE !');\n\t\t}\n\t  }\n\n    const selectAlgorithm = (algorithm) => {\n        switch(algorithm) {\n          case \"kruskal\": { setAlgorithm('KRUSKAL MAZE !'); break; }\n          case \"prim\": { setAlgorithm('PRIM MAZE !'); break; }\n          case \"wilson\": { setAlgorithm('WILSON MAZE !'); break; }\n          case \"aldous\": { setAlgorithm('ALDOUS-BRODER MAZE !'); break; }\n          default: { break;}\n        }\n    }\n\n\tconst visualizeKruskal = () => {\n\t\tconst openEdgesInOrder = kruskal(grid);\n\n\t\t//Put all nodes to wall mode\n\t\tfor(let [rowkey, row] of grid.entries()){\n\t\t\tfor(let [nodekey, node] of row.entries()){\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(rowkey, new Map(prev.get(rowkey))\n\t\t\t\t\t\t\t.set(nodekey, {...node, isWall: true,})) );\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < openEdgesInOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].center.row, new Map(prev.get(openEdgesInOrder[i].center.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].center.col, {...openEdgesInOrder[i].center, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].first.row, new Map(prev.get(openEdgesInOrder[i].first.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].first.col, {...openEdgesInOrder[i].first, isWall: false,})) );\n\t\t\t\tsetGrid( (prev) => new Map(prev).set(openEdgesInOrder[i].second.row, new Map(prev.get(openEdgesInOrder[i].second.row))\n\t\t\t\t\t\t\t.set(openEdgesInOrder[i].second.col, {...openEdgesInOrder[i].second, isWall: false,})) );\n\t\t\t}, 5)\n\t\t}\n\t}\n\t\n\n\treturn (\n\t\t<div className=\"container\">\n\t\t\t<div className=\"mazes\">\n\t\t\t\t<span>Maze algorithm</span>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('kruskal')}>Kruskal's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('prim')}>Prim's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('wilson')}>Wilson's algorithm</span>\n\t\t\t\t\t<span onClick={()=>selectAlgorithm('aldous')}>Aldous-Broder algorithm</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<input className=\"vizualize\" type=\"submit\" value={algorithm} onClick={()=>visualizeGo(algorithm)}/>\n\t\t</div>\n\t);\n}\n","import React from 'react'\nimport './NavBar.scss'\nimport ReactTooltip from 'react-tooltip';\nimport Reset from './icons/Reset';\nimport Help from './icons/Help';\nimport Pathfindings from './pathfindings/Pathfindings';\nimport Mazes from './mazes/Mazes';\n\nexport default function NavBar() {\n\n    return (\n        <div className='navbar'>\n            <div className=\"container\">\n\t\t\t\t<div className=\"left\">\n\t\t\t\t\t<div className=\"logo\">\n\t\t\t\t\t\t<img src=\"https://cdn-icons-png.flaticon.com/512/182/182580.png\" alt=\"from flaticon\" />\n\t\t\t\t\t\t<span>Pathfinder</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<Mazes/>\n          \t\t\t<Pathfindings/>\n\t\t\t\t</div>\n        <div className=\"right\">\n\t\t\t\t\t<Reset/>\n\t\t\t\t\t<Help/>\n\t\t\t\t\t<ReactTooltip className='tooltip-class' delayHide={500} place='bottom' effect='solid' globalEventOff=\"click\" />\n\t\t\t\t</div>\n\t\t\t</div>\n        </div>\n    )\n}\n","import React from 'react'\nimport Grid from '../components/grid/Grid'\nimport NavBar from '../components/navbar/NavBar'\nimport StoreProvider from '../utils/StoreProvider'\nimport './Home.scss'\n\nexport default function home() {\n    return (\n        <StoreProvider>\n            <div className='home'>\n                <NavBar/>\n                <Grid/>\n            </div>\n        </StoreProvider>\n    )\n}\n","import './App.scss';\nimport Home from './home/Home';\n\nfunction App() {\n  return (\n    <div>\n      <Home/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}